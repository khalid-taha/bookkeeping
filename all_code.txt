===== ./app/api/accounts_api.py =====
# app/api/accounts_api.py

from flask import request
from flask_restx import Namespace, Resource, fields
from modules.models.account import Account
from modules.database.db import db
from flask_login import login_required
from . import api

accounts_ns = Namespace('accounts', description='Accounts related operations')

account_model = accounts_ns.model('Account', {
    'id': fields.Integer(readOnly=True, description='The unique identifier of an account'),
    'name': fields.String(required=True, description='Account name'),
    'type': fields.String(required=True, description='Account type')
})

@accounts_ns.route('/')
class AccountList(Resource):
    @accounts_ns.marshal_list_with(account_model)
    @login_required
    def get(self):
        """List all accounts"""
        accounts = Account.query.all()
        return accounts, 200

    @accounts_ns.expect(account_model, validate=True)
    @accounts_ns.marshal_with(account_model, code=201)
    @login_required
    def post(self):
        """Create a new account"""
        data = request.json
        if db.session.execute(db.select(Account).filter_by(name=data['name'])).scalar():
            accounts_ns.abort(400, 'Account name already exists.')
        new_account = Account(name=data['name'], type=data['type'])
        db.session.add(new_account)
        db.session.commit()
        return new_account, 201

@accounts_ns.route('/<int:id>')
@accounts_ns.response(404, 'Account not found')
@accounts_ns.param('id', 'The account identifier')
class AccountResource(Resource):
    @accounts_ns.marshal_with(account_model)
    @login_required
    def get(self, id):
        """Fetch a given account"""
        account = db.session.get(Account, id)
        if not account:
            accounts_ns.abort(404, 'Account not found')
        return account, 200

    @accounts_ns.expect(account_model, validate=True)
    @accounts_ns.marshal_with(account_model)
    @login_required
    def put(self, id):
        """Update a given account"""
        account = db.session.get(Account, id)
        if not account:
            accounts_ns.abort(404, 'Account not found')
        data = request.json
        if 'name' in data:
            if db.session.execute(db.select(Account).filter(Account.name == data['name'], Account.id != id)).scalar():
                accounts_ns.abort(400, 'Another account with this name already exists.')
            account.name = data['name']
        if 'type' in data:
            account.type = data['type']
        db.session.commit()
        return account, 200

    @accounts_ns.response(204, 'Account deleted')
    @login_required
    def delete(self, id):
        """Delete a given account"""
        account = db.session.get(Account, id)
        if not account:
            accounts_ns.abort(404, 'Account not found')
        db.session.delete(account)
        db.session.commit()
        return '', 204
===== ./app/api/auth_api.py =====
# app/api/auth_api.py

from flask import request
from modules.models.user import User
from modules.database.db import db
from werkzeug.security import check_password_hash
from flask_login import login_user, logout_user, login_required, current_user
from flask_restx import Namespace, Resource, fields
from . import api

auth_ns = Namespace('auth', description='Authentication related operations')

login_model = auth_ns.model('Login', {
    'username': fields.String(required=True, description='Username'),
    'password': fields.String(required=True, description='Password')
})

user_model = auth_ns.model('User', {
    'id': fields.Integer(readOnly=True, description='User ID'),
    'username': fields.String(required=True, description='Username'),
    'role': fields.String(required=True, description='User role')
})

@auth_ns.route('/login')
class Login(Resource):
    @auth_ns.expect(login_model, validate=True)
    @auth_ns.marshal_with(user_model)
    def post(self):
        """Authenticate a user and log them in"""
        data = request.json
        user = db.session.execute(db.select(User).filter_by(username=data['username'])).scalar()
        if user and check_password_hash(user.password_hash, data['password']):
            login_user(user)
            return user, 200
        else:
            auth_ns.abort(400, 'Invalid username or password.')

@auth_ns.route('/logout')
class Logout(Resource):
    @login_required
    def post(self):
        """Log the current user out"""
        logout_user()
        return {'message': 'Logged out successfully.'}, 200

@auth_ns.route('/user')
class CurrentUser(Resource):
    @login_required
    @auth_ns.marshal_with(user_model)
    def get(self):
        """Get the current logged-in user's information"""
        return current_user, 200
===== ./app/api/transactions_api.py =====
# app/api/transactions_api.py

from flask import request
from flask_restx import Namespace, Resource, fields
from modules.models.transaction import Transaction
from modules.models.account import Account
from modules.database.db import db
from flask_login import login_required
from . import api
from dateutil import parser

transactions_ns = Namespace('transactions', description='Transactions related operations')

transaction_model = transactions_ns.model('Transaction', {
    'id': fields.Integer(readOnly=True, description='The unique identifier of a transaction'),
    'date': fields.DateTime(required=True, description='Date of the transaction'),
    'amount': fields.Float(required=True, description='Amount of the transaction'),
    'description': fields.String(required=True, description='Description of the transaction'),
    'debit_account_id': fields.Integer(required=True, description='Debit account ID'),
    'credit_account_id': fields.Integer(required=True, description='Credit account ID')
})

transaction_update_model = transactions_ns.model('TransactionUpdate', {
    'date': fields.DateTime(description='Date of the transaction'),
    'amount': fields.Float(description='Amount of the transaction'),
    'description': fields.String(description='Description of the transaction'),
    'debit_account_id': fields.Integer(description='Debit account ID'),
    'credit_account_id': fields.Integer(description='Credit account ID')
})

@transactions_ns.route('/')
class TransactionList(Resource):
    @transactions_ns.marshal_list_with(transaction_model)
    @login_required
    def get(self):
        """List all transactions"""
        transactions = Transaction.query.all()
        return transactions, 200

    @transactions_ns.expect(transaction_model, validate=True)
    @transactions_ns.marshal_with(transaction_model, code=201)
    @login_required
    def post(self):
        """Create a new transaction"""
        data = request.json
        required_fields = ['date', 'amount', 'description', 'debit_account_id', 'credit_account_id']
        if not all(field in data for field in required_fields):
            transactions_ns.abort(400, 'All fields are required.')

        # Validate accounts exist
        debit_account = db.session.get(Account, data['debit_account_id'])
        credit_account = db.session.get(Account, data['credit_account_id'])
        if not debit_account or not credit_account:
            transactions_ns.abort(400, 'Invalid debit or credit account ID.')

        # Parse and validate date
        try:
            date = parser.isoparse(data['date'])
        except (ValueError, TypeError):
            transactions_ns.abort(400, 'Invalid date format.')

        new_transaction = Transaction(
            date=date,
            amount=data['amount'],
            description=data['description'],
            debit_account_id=data['debit_account_id'],
            credit_account_id=data['credit_account_id']
        )
        db.session.add(new_transaction)
        db.session.commit()
        return new_transaction, 201

@transactions_ns.route('/<int:id>')
@transactions_ns.response(404, 'Transaction not found')
@transactions_ns.param('id', 'The transaction identifier')
class TransactionResource(Resource):
    @transactions_ns.marshal_with(transaction_model)
    @login_required
    def get(self, id):
        """Fetch a given transaction"""
        transaction = db.session.get(Transaction, id)
        if not transaction:
            transactions_ns.abort(404, 'Transaction not found')
        return transaction, 200

    @transactions_ns.expect(transaction_update_model, validate=True)
    @transactions_ns.marshal_with(transaction_model)
    @login_required
    def put(self, id):
        """Update a given transaction"""
        transaction = db.session.get(Transaction, id)
        if not transaction:
            transactions_ns.abort(404, 'Transaction not found')
        data = request.json

        if 'date' in data:
            try:
                transaction.date = parser.isoparse(data['date'])
            except (ValueError, TypeError):
                transactions_ns.abort(400, 'Invalid date format.')

        if 'amount' in data:
            transaction.amount = data['amount']

        if 'description' in data:
            transaction.description = data['description']

        if 'debit_account_id' in data:
            debit_account = db.session.get(Account, data['debit_account_id'])
            if not debit_account:
                transactions_ns.abort(400, 'Invalid debit account ID.')
            transaction.debit_account_id = data['debit_account_id']

        if 'credit_account_id' in data:
            credit_account = db.session.get(Account, data['credit_account_id'])
            if not credit_account:
                transactions_ns.abort(400, 'Invalid credit account ID.')
            transaction.credit_account_id = data['credit_account_id']

        db.session.commit()
        return transaction, 200

    @transactions_ns.response(204, 'Transaction deleted')
    @login_required
    def delete(self, id):
        """Delete a given transaction"""
        transaction = db.session.get(Transaction, id)
        if not transaction:
            transactions_ns.abort(404, 'Transaction not found')
        db.session.delete(transaction)
        db.session.commit()
        return '', 204
===== ./app/api/__init__.py =====
# app/api/__init__.py

from flask import Blueprint
from flask_restx import Api

api_bp = Blueprint('api', __name__, url_prefix='/api')
api = Api(api_bp, version='1.0', title='Bookkeeping API',
          description='APIs for Internal Module Communication')

# Import API modules
from .accounts_api import accounts_ns
from .transactions_api import transactions_ns
from .auth_api import auth_ns

# Add Namespaces to the API
api.add_namespace(accounts_ns)
api.add_namespace(transactions_ns)
api.add_namespace(auth_ns)===== ./app/main.py =====
# app/main.py
from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run()===== ./app/static/__init__.py =====
===== ./app/templates/account_form.html =====
<!-- app/templates/account_form.html -->

{% extends "base.html" %}

{% block title %}Create Account{% endblock %}

{% block content %}
<h2>Create New Account</h2>
<form method="post">
    {{ form.hidden_tag() }}
    
    <!-- Display Form Errors -->
    {% if form.errors %}
        <ul class="errors">
            {% for field, errors in form.errors.items() %}
                {% for error in errors %}
                    <li>{{ error }}</li>
                {% endfor %}
            {% endfor %}
        </ul>
    {% endif %}
    
    <p>
        {{ form.name.label }}<br>
        {{ form.name(size=32) }}
    </p>
    <p>
        {{ form.type.label }}<br>
        {{ form.type() }}
    </p>
    <p>{{ form.submit() }}</p>
</form>
{% endblock %}
===== ./app/templates/account_list.html =====
<!-- app/templates/account_list.html -->

{% extends "base.html" %}

{% block title %}Account List{% endblock %}

{% block content %}
<h1>Accounts</h1>
<ul>
    {% for account in accounts %}
        <li>{{ account.name }} - {{ account.type }}</li>
    {% endfor %}
</ul>
<a href="{{ url_for('accounts.new_account') }}">Create New Account</a>
{% endblock %}
===== ./app/templates/base.html =====
<!-- app/templates/base.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Bookkeeping App{% endblock %}</title>
    
    <!-- Add CSS Styles for Error Messages and Flash Messages -->
    <style>
        /* Style for form validation errors */
        .errors {
            color: red;
            list-style-type: none;
            padding: 0;
        }

        /* Style for flash messages */
        .flash-message {
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .flash-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .flash-message.danger {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            <div class="flash-messages">
                {% for category, message in messages %}
                    <div class="flash-message {{ category }}">
                        {{ message }}
                    </div>
                {% endfor %}
            </div>
        {% endif %}
    {% endwith %}
    {% block content %}{% endblock %}
</body>
</html>
===== ./app/templates/index.html =====
<!-- app/templates/index.html -->

{% extends "base.html" %}

{% block title %}Home - Bookkeeping App{% endblock %}

{% block content %}
<h1>Welcome to the Bookkeeping Application</h1>
<nav>
    <a href="{{ url_for('auth.login') }}">Login</a> |
    <a href="{{ url_for('accounts.list_accounts') }}">Accounts</a> |
    <a href="{{ url_for('transactions.list_transactions') }}">Transactions</a>
</nav>
{% endblock %}
===== ./app/templates/login.html =====
<!-- app/templates/login.html -->

{% extends "base.html" %}

{% block title %}Login{% endblock %}

{% block content %}
<h2>Login</h2>
<form method="post">
    {{ form.hidden_tag() }}
    <p>
        {{ form.username.label }}<br>
        {{ form.username(size=32) }}
    </p>
    <p>
        {{ form.password.label }}<br>
        {{ form.password(size=32) }}
    </p>
    <p>{{ form.submit() }}</p>
</form>
{% endblock %}
===== ./app/templates/transaction_form.html =====
<!-- app/templates/transaction_form.html -->

{% extends "base.html" %}

{% block title %}Create Transaction{% endblock %}

{% block content %}
<h2>Create New Transaction</h2>

{% if form.errors %}
    <ul class="errors">
        {% for field, errors in form.errors.items() %}
            {% for error in errors %}
                <li>{{ error }}</li>
            {% endfor %}
        {% endfor %}
    </ul>
{% endif %}

<form method="post">
    {{ form.hidden_tag() }}
    <p>
        {{ form.date.label }}<br>
        {{ form.date(type='date') }}  <!-- Set input type to 'date' -->
    </p>
    <p>
        {{ form.amount.label }}<br>
        {{ form.amount() }}
    </p>
    <p>
        {{ form.description.label }}<br>
        {{ form.description(size=64) }}
    </p>
    <p>
        {{ form.debit_account.label }}<br>
        {{ form.debit_account() }}
    </p>
    <p>
        {{ form.credit_account.label }}<br>
        {{ form.credit_account() }}
    </p>
    <p>{{ form.submit() }}</p>
</form>
{% endblock %}
===== ./app/templates/transaction_list.html =====
<!-- app/templates/transaction_list.html -->

{% extends "base.html" %}

{% block title %}Transaction List{% endblock %}

{% block content %}
<h2>Transactions</h2>
<ul>
    {% for transaction in transactions %}
        <li>{{ transaction.description }} - {{ transaction.amount }} on {{ transaction.date.strftime('%Y-%m-%d %H:%M:%S') }}</li>
    {% endfor %}
</ul>
<a href="{{ url_for('transactions.new_transaction') }}">Create New Transaction</a>
{% endblock %}
===== ./app/templates/__init__.py =====
===== ./app/views/accounts.py =====
# app/views/accounts.py

from flask import Blueprint, render_template, redirect, url_for, flash, request
from modules.forms.account_form import AccountForm
from modules.models.account import Account
from modules.database.db import db
from flask_login import login_required

bp = Blueprint('accounts', __name__, url_prefix='/accounts')

@bp.route('/new', methods=['GET', 'POST'])
@login_required
def new_account():
    form = AccountForm()
    if form.validate_on_submit():
        account = Account(
            name=form.name.data,
            type=form.type.data
        )
        db.session.add(account)
        db.session.commit()
        flash('Account created successfully.', 'success')
        return redirect(url_for('accounts.list_accounts'))
    return render_template('account_form.html', form=form)


@bp.route('/', methods=['GET'])
@login_required
def list_accounts():
    accounts = Account.query.all()
    return render_template('account_list.html', accounts=accounts)
===== ./app/views/auth.py =====
# app/views/auth.py

from flask import Blueprint, render_template, redirect, url_for, flash, request
from modules.forms.login_form import LoginForm
from modules.models.user import User
from modules.database.db import db
from werkzeug.security import check_password_hash
from flask_login import login_user, logout_user, login_required

bp = Blueprint('auth', __name__, url_prefix='/auth')

@bp.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user and check_password_hash(user.password_hash, form.password.data):
            login_user(user)
            flash('Logged in successfully.', 'success')
            return redirect(url_for('main.index'))
        else:
            flash('Invalid username or password.', 'danger')
            return render_template('login.html', form=form), 400  # Return 400 on failure
    return render_template('login.html', form=form)

@bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out.', 'success')
    return redirect(url_for('main.index'))
===== ./app/views/main.py =====
# app/views/main.py

from flask import Blueprint, render_template

bp = Blueprint('main', __name__, url_prefix='/')

@bp.route('/')
def index():
    return render_template('index.html')  # Ensure this template exists
===== ./app/views/transactions.py =====
# app/views/transactions.py

from flask import Blueprint, render_template, redirect, url_for, flash, request
from modules.forms.transaction_form import TransactionForm
from modules.models.transaction import Transaction
from modules.models.account import Account
from modules.database.db import db
from sqlalchemy.exc import IntegrityError
from flask_login import login_required

bp = Blueprint('transactions', __name__, url_prefix='/transactions')

@bp.route('/new', methods=['GET', 'POST'])
@login_required
def new_transaction():
    form = TransactionForm()
    # Populate account choices
    form.debit_account.choices = [(account.id, account.name) for account in Account.query.all()]
    form.credit_account.choices = [(account.id, account.name) for account in Account.query.all()]
    
    if form.validate_on_submit():
        transaction = Transaction(
            date=form.date.data,
            amount=form.amount.data,
            description=form.description.data,
            debit_account_id=form.debit_account.data,
            credit_account_id=form.credit_account.data
        )
        db.session.add(transaction)
        try:
            db.session.commit()
            flash('Transaction created successfully.', 'success')
            return redirect(url_for('transactions.list_transactions'))
        except IntegrityError:
            db.session.rollback()
            flash('Error creating transaction.', 'danger')
            return render_template('transaction_form.html', form=form), 400
    return render_template('transaction_form.html', form=form)

@bp.route('/', methods=['GET'])
@login_required
def list_transactions():
    transactions = Transaction.query.all()
    return render_template('transaction_list.html', transactions=transactions)
===== ./app/views/__init__.py =====
# app/views/__init__.py

from app.views.accounts import bp as accounts_bp
from app.views.transactions import bp as transactions_bp
from app.views.auth import bp as auth_bp

__all__ = ['accounts_bp', 'transactions_bp', 'auth_bp']
===== ./app/__init__.py =====
# app/__init__.py

from flask import Flask
from modules.database.db import db
from modules.services import ma  # Marshmallow instance
from flask_migrate import Migrate
from flask_login import LoginManager
from app.views.main import bp as main_bp
from app.views.auth import bp as auth_bp
from app.views.accounts import bp as accounts_bp
from app.views.transactions import bp as transactions_bp
from app.api import api_bp  # Import the API blueprint
from flask import make_response, jsonify, request, redirect, url_for

def create_app(config_object='config.DevelopmentConfig'):
    app = Flask(__name__)
    app.config.from_object(config_object)

    # Initialize extensions
    db.init_app(app)
    ma.init_app(app)  # Initialize Marshmallow
    migrate = Migrate(app, db)

    # Initialize Flask-Login
    login_manager = LoginManager()
    login_manager.login_view = 'auth.login'
    login_manager.init_app(app)

    @login_manager.user_loader
    def load_user(user_id):
        from modules.models.user import User
        return User.query.get(int(user_id))

    @login_manager.unauthorized_handler
    def unauthorized():
        if request.path.startswith('/api/'):
            return make_response(jsonify({'message': 'Unauthorized access'}), 401)
        else:
            return redirect(url_for('auth.login', next=request.url))

    # Register Blueprints
    app.register_blueprint(main_bp)
    app.register_blueprint(auth_bp)
    app.register_blueprint(accounts_bp)
    app.register_blueprint(transactions_bp)
    app.register_blueprint(api_bp)  # Register the API blueprint

    return app

===== ./config.py =====
# config.py
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY', 'your_secret_key')
    
    # Generate absolute path for the database
    basedir = os.path.abspath(os.path.dirname(__file__))
    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(basedir, 'data', 'app.db')
    
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'  # In-memory DB for testing
    WTF_CSRF_ENABLED = False  # Disable CSRF for testing
===== ./create_user.py =====
# create_user.py

from app import create_app
from modules.database.db import db
from modules.models.user import User
from werkzeug.security import generate_password_hash

app = create_app()

with app.app_context():
    # Replace 'admin' and 'admin123' with your desired username and password
    username = 'admin'
    password = 'securepassword123'
    role = 'Admin'

    # Check if the user already exists
    if not User.query.filter_by(username=username).first():
        user = User(
            username=username,
            password_hash=generate_password_hash(password),
            role=role
        )
        db.session.add(user)
        db.session.commit()
        print(f'User {username} created successfully.')
    else:
        print(f'User {username} already exists.')
===== ./migrations/env.py =====
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
===== ./migrations/versions/4754bb485e92_initial_migration.py =====
"""Initial migration

Revision ID: 4754bb485e92
Revises: 
Create Date: 2024-11-07 00:05:34.478156

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '4754bb485e92'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('accounts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=150), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=150), nullable=False),
    sa.Column('password_hash', sa.String(length=255), nullable=False),
    sa.Column('role', sa.String(length=50), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('username')
    )
    op.create_table('transactions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('date', sa.Date(), nullable=False),
    sa.Column('amount', sa.Float(), nullable=False),
    sa.Column('description', sa.String(length=255), nullable=False),
    sa.Column('debit_account_id', sa.Integer(), nullable=False),
    sa.Column('credit_account_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['credit_account_id'], ['accounts.id'], ),
    sa.ForeignKeyConstraint(['debit_account_id'], ['accounts.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('transactions')
    op.drop_table('users')
    op.drop_table('accounts')
    # ### end Alembic commands ###
===== ./modules/database/db.py =====
# modules/database/db.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()===== ./modules/database/__init__.py =====
===== ./modules/forms/account_form.py =====
# modules/forms/account_form.py
from flask_wtf import FlaskForm
from wtforms import StringField, SelectField, SubmitField
from wtforms.validators import DataRequired, ValidationError
from modules.models.account import Account

class AccountForm(FlaskForm):
    name = StringField('Account Name', validators=[DataRequired()])
    type = SelectField('Account Type', choices=[
        ('Asset', 'Asset'),
        ('Liability', 'Liability'),
        ('Equity', 'Equity'),
        ('Revenue', 'Revenue'),
        ('Expense', 'Expense')
    ], validators=[DataRequired()])
    submit = SubmitField('Create Account')

    def validate_name(self, field):
        if Account.query.filter_by(name=field.data).first():
            raise ValidationError('Account name already exists.')===== ./modules/forms/login_form.py =====
# modules/forms/login_form.py

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField
from wtforms.validators import DataRequired

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Login')
===== ./modules/forms/transaction_form.py =====
# modules/forms/transaction_form.py

from flask_wtf import FlaskForm
from wtforms import StringField, FloatField, SelectField, DateField, SubmitField
from wtforms.validators import DataRequired

class TransactionForm(FlaskForm):
    date = DateField(
        'Date',
        format='%Y-%m-%d',
        validators=[DataRequired(message="Please enter a valid date. Format: YYYY-MM-DD")]
    )
    amount = FloatField('Amount', validators=[DataRequired(message="Please enter a valid amount.")])
    description = StringField('Description', validators=[DataRequired(message="Description is required.")])
    debit_account = SelectField('Debit Account', coerce=int, validators=[DataRequired(message="Please select a debit account.")])
    credit_account = SelectField('Credit Account', coerce=int, validators=[DataRequired(message="Please select a credit account.")])
    submit = SubmitField('Create Transaction')
===== ./modules/forms/__init__.py =====
===== ./modules/ml/models/__init__.py =====
===== ./modules/ml/training/__init__.py =====
===== ./modules/ml/utils/__init__.py =====
===== ./modules/ml/__init__.py =====
===== ./modules/models/account.py =====
# modules/models/account.py

from modules.database.db import db

class Account(db.Model):
    __tablename__ = 'accounts'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(150), unique=True, nullable=False)
    type = db.Column(db.String(50), nullable=False)

    def __repr__(self):
        return f"<Account {self.name}>"
===== ./modules/models/transaction.py =====
# modules/models/transaction.py

from modules.database.db import db
from modules.models.account import Account

class Transaction(db.Model):
    __tablename__ = 'transactions'
    id = db.Column(db.Integer, primary_key=True)
    date = db.Column(db.Date, nullable=False)  # Changed from db.DateTime to db.Date
    amount = db.Column(db.Float, nullable=False)
    description = db.Column(db.String(255), nullable=False)
    debit_account_id = db.Column(db.Integer, db.ForeignKey('accounts.id'), nullable=False)
    credit_account_id = db.Column(db.Integer, db.ForeignKey('accounts.id'), nullable=False)

    debit_account = db.relationship('Account', foreign_keys=[debit_account_id])
    credit_account = db.relationship('Account', foreign_keys=[credit_account_id])

    def __repr__(self):
        return f"<Transaction {self.id} - {self.description}>"
===== ./modules/models/user.py =====
# modules/models/user.py

from modules.database.db import db
from flask_login import UserMixin

class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(50), nullable=False)

    def __repr__(self):
        return f"<User {self.username}>"
===== ./modules/models/__init__.py =====
===== ./modules/services/decorators.py =====
# modules/services/decorators.py

from functools import wraps
from flask import jsonify
from flask_login import current_user

def roles_required(*roles):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            if current_user.role not in roles:
                return jsonify({'error': 'Unauthorized access.'}), 403
            return f(*args, **kwargs)
        return decorated_function
    return decorator===== ./modules/services/schemas.py =====
# modules/services/schemas.py

from marshmallow_sqlalchemy import SQLAlchemyAutoSchema
from modules.models.account import Account
from modules.models.transaction import Transaction
from modules.models.user import User

class AccountSchema(SQLAlchemyAutoSchema):
    class Meta:
        model = Account
        load_instance = True

class TransactionSchema(SQLAlchemyAutoSchema):
    class Meta:
        model = Transaction
        load_instance = True

class UserSchema(SQLAlchemyAutoSchema):
    class Meta:
        model = User
        load_instance = True
        exclude = ('password_hash',)
===== ./modules/services/__init__.py =====
# modules/services/__init__.py

from flask_marshmallow import Marshmallow

ma = Marshmallow()
===== ./modules/__init__.py =====
===== ./tests/api/test_accounts_api.py =====
# tests/api/test_accounts_api.py

import pytest

@pytest.fixture
def new_account_data():
    return {
        'name': 'Test Account',
        'type': 'Asset'
    }

def login(client, test_user):
    client.post('/api/auth/login', json={
        'username': test_user.username,
        'password': 'testpass'
    })

def test_get_accounts(client, test_user):
    login(client, test_user)
    response = client.get('/api/accounts/')
    assert response.status_code == 200
    assert isinstance(response.json, list)

def test_create_account(client, db, test_user, new_account_data):
    login(client, test_user)
    response = client.post('/api/accounts/', json=new_account_data)
    assert response.status_code == 201
    assert response.json['name'] == new_account_data['name']

def test_create_duplicate_account(client, db, test_user, new_account_data):
    login(client, test_user)
    client.post('/api/accounts/', json=new_account_data)
    response = client.post('/api/accounts/', json=new_account_data)
    assert response.status_code == 400
    assert 'Account name already exists.' in response.json['message']

def test_get_single_account(client, db, test_user, new_account_data):
    login(client, test_user)
    response = client.post('/api/accounts/', json=new_account_data)
    account_id = response.json['id']
    response = client.get(f'/api/accounts/{account_id}')
    assert response.status_code == 200
    assert response.json['id'] == account_id

def test_update_account(client, db, test_user, new_account_data):
    login(client, test_user)
    response = client.post('/api/accounts/', json=new_account_data)
    account_id = response.json['id']
    updated_data = {'name': 'Updated Account', 'type': 'Liability'}
    response = client.put(f'/api/accounts/{account_id}', json=updated_data)
    assert response.status_code == 200
    assert response.json['name'] == updated_data['name']

def test_delete_account(client, db, test_user, new_account_data):
    login(client, test_user)
    response = client.post('/api/accounts/', json=new_account_data)
    account_id = response.json['id']
    response = client.delete(f'/api/accounts/{account_id}')
    assert response.status_code == 204
    response = client.get(f'/api/accounts/{account_id}')
    assert response.status_code == 404
===== ./tests/api/test_auth_api.py =====
# tests/api/test_auth_api.py

import pytest

def test_login(client, test_user):
    response = client.post('/api/auth/login', json={
        'username': test_user.username,
        'password': 'testpass'
    })
    assert response.status_code == 200
    assert response.json['username'] == test_user.username

def test_login_invalid_credentials(client):
    response = client.post('/api/auth/login', json={
        'username': 'wronguser',
        'password': 'wrongpass'
    })
    assert response.status_code == 400
    assert 'Invalid username or password.' in response.json['message']

def test_get_current_user(client, test_user):
    # Log in first
    client.post('/api/auth/login', json={
        'username': test_user.username,
        'password': 'testpass'
    })

    # Get current user
    response = client.get('/api/auth/user')
    assert response.status_code == 200
    assert response.json['username'] == test_user.username

def test_logout(client, test_user):
    # Log in first
    client.post('/api/auth/login', json={
        'username': test_user.username,
        'password': 'testpass'
    })

    # Log out
    response = client.post('/api/auth/logout')
    assert response.status_code == 200
    assert response.json['message'] == 'Logged out successfully.'

    # Attempt to access protected endpoint
    response = client.get('/api/auth/user')
    assert response.status_code == 401 or response.status_code == 302  # Depending on your setup
===== ./tests/api/test_transactions_api.py =====
# tests/api/test_transactions_api.py

import pytest
from datetime import datetime, timezone
from modules.models.account import Account

@pytest.fixture
def setup_accounts(db):
    debit_account = Account(name='Debit Account', type='Asset')
    credit_account = Account(name='Credit Account', type='Revenue')
    db.session.add_all([debit_account, credit_account])
    db.session.commit()
    return debit_account, credit_account

@pytest.fixture
def new_transaction_data(setup_accounts):
    debit_account, credit_account = setup_accounts
    return {
        'date': datetime.now(timezone.utc).isoformat(),
        'amount': 100.0,
        'description': 'Test Transaction',
        'debit_account_id': debit_account.id,
        'credit_account_id': credit_account.id
    }

def login(client, test_user):
    client.post('/api/auth/login', json={
        'username': test_user.username,
        'password': 'testpass'
    })

def test_get_transactions(client, test_user):
    login(client, test_user)
    response = client.get('/api/transactions/')
    assert response.status_code == 200
    assert isinstance(response.json, list)

def test_create_transaction(client, db, test_user, new_transaction_data):
    login(client, test_user)
    response = client.post('/api/transactions/', json=new_transaction_data)
    assert response.status_code == 201
    assert response.json['description'] == new_transaction_data['description']

def test_get_single_transaction(client, db, test_user, new_transaction_data):
    login(client, test_user)
    response = client.post('/api/transactions/', json=new_transaction_data)
    transaction_id = response.json['id']
    response = client.get(f'/api/transactions/{transaction_id}')
    assert response.status_code == 200
    assert response.json['id'] == transaction_id

def test_update_transaction(client, db, test_user, new_transaction_data):
    login(client, test_user)
    response = client.post('/api/transactions/', json=new_transaction_data)
    transaction_id = response.json['id']
    updated_data = {
        'description': 'Updated Transaction',
        'amount': 150.0
    }
    response = client.put(f'/api/transactions/{transaction_id}', json=updated_data)
    assert response.status_code == 200
    assert response.json['description'] == updated_data['description']
    assert response.json['amount'] == updated_data['amount']

def test_delete_transaction(client, db, test_user, new_transaction_data):
    login(client, test_user)
    response = client.post('/api/transactions/', json=new_transaction_data)
    transaction_id = response.json['id']
    response = client.delete(f'/api/transactions/{transaction_id}')
    assert response.status_code == 204
    response = client.get(f'/api/transactions/{transaction_id}')
    assert response.status_code == 404
===== ./tests/api/__init__.py =====
===== ./tests/conftest.py =====
# tests/conftest.py

import pytest
from app import create_app
from modules.database.db import db as _db
from modules.models.user import User
from werkzeug.security import generate_password_hash

@pytest.fixture(scope='function')
def app():
    app = create_app('config.TestingConfig')
    app.config['TESTING'] = True
    with app.app_context():
        yield app

@pytest.fixture(scope='function')
def db(app):
    _db.create_all()
    yield _db
    _db.session.remove()
    _db.drop_all()

@pytest.fixture(scope='function')
def test_user(db):
    user = User(
        username='testuser',
        password_hash=generate_password_hash('testpass'),
        role='User'
    )
    db.session.add(user)
    db.session.commit()
    return user

@pytest.fixture(scope='function')
def client(app, db):
    return app.test_client()
===== ./tests/test_models.py =====
# tests/test_models.py

from datetime import date

def test_transaction_model(db):
    from modules.models.account import Account
    from modules.models.transaction import Transaction

    # Add unique accounts
    debit_account = Account(name='Cash_Test', type='Asset')
    credit_account = Account(name='Revenue_Test', type='Revenue')

    db.session.add_all([debit_account, credit_account])
    db.session.commit()

    # Use date object for the date field
    transaction_date = date.today()

    # Create a transaction with date
    transaction = Transaction(
        date=transaction_date,
        debit_account_id=debit_account.id,
        credit_account_id=credit_account.id,
        amount=1000.00,
        description='Test Transaction'
    )

    db.session.add(transaction)
    db.session.commit()

    # Assertions
    assert transaction.id is not None
    assert transaction.date == transaction_date
    assert transaction.debit_account.name == 'Cash_Test'
    assert transaction.credit_account.name == 'Revenue_Test'
===== ./tests/test_views.py =====
# tests/test_views.py

from datetime import date, datetime, timezone
import pytest
from modules.models.account import Account
from modules.models.transaction import Transaction

def login(client, test_user):
    # Log in the test client
    response = client.post('/auth/login', data={
        'username': test_user.username,
        'password': 'testpass'
    }, follow_redirects=True)
    assert response.status_code == 200
    assert b'Logged in successfully.' in response.data

def test_new_account(client, db, test_user):
    login(client, test_user)
    # Create a unique account name using timestamp
    unique_account_name = f'Bank_Test_{datetime.now(timezone.utc).timestamp()}'

    # Create the account successfully
    response = client.post('/accounts/new', data={
        'name': unique_account_name,
        'type': 'Asset',
        'submit': 'Create Account'
    }, follow_redirects=True)

    assert response.status_code == 200
    assert b'Account created successfully.' in response.data

    # Attempt to create the same account again to test uniqueness
    response_duplicate = client.post('/accounts/new', data={
        'name': unique_account_name,
        'type': 'Asset',
        'submit': 'Create Account'
    }, follow_redirects=True)

    assert response_duplicate.status_code == 200
    assert b'Account name already exists.' in response_duplicate.data

def test_new_transaction(client, db, test_user):
    login(client, test_user)
    # Create accounts needed for the transaction
    debit_account = Account(name='Cash_Test', type='Asset')
    credit_account = Account(name='Revenue_Test', type='Revenue')

    db.session.add_all([debit_account, credit_account])
    db.session.commit()

    # Prepare transaction data
    transaction_data = {
        'date': date.today().strftime('%Y-%m-%d'),
        'amount': '500.00',
        'description': 'Test Transaction via Web',
        'debit_account': str(debit_account.id),
        'credit_account': str(credit_account.id),
        'submit': 'Create Transaction'
    }

    # Create the transaction via the web interface
    response = client.post('/transactions/new', data=transaction_data, follow_redirects=True)

    assert response.status_code == 200
    assert b'Transaction created successfully.' in response.data

    # Verify the transaction was saved in the database
    transaction = Transaction.query.filter_by(description='Test Transaction via Web').first()
    assert transaction is not None
    assert transaction.amount == 500.00
    assert transaction.date == date.today()
    assert transaction.debit_account_id == debit_account.id
    assert transaction.credit_account_id == credit_account.id

def test_new_transaction_invalid_data(client, db, test_user):
    login(client, test_user)
    # Prepare incomplete transaction data
    transaction_data = {
        'date': '',
        'amount': '',
        'description': '',
        'debit_account': '',
        'credit_account': '',
        'submit': 'Create Transaction'
    }

    # Attempt to create the transaction
    response = client.post('/transactions/new', data=transaction_data, follow_redirects=True)

    assert response.status_code == 200
    assert b'Please enter a valid date' in response.data
    assert b'Please enter a valid amount' in response.data
    assert b'Description is required' in response.data
    assert b'Please select a debit account' in response.data
    assert b'Please select a credit account' in response.data

    # Ensure no transaction was created
    transaction = Transaction.query.filter_by(description='').first()
    assert transaction is None
===== ./tests/__init__.py =====
