===== ./app/main.py =====
# app/main.py
from app import create_app

app = create_app()

if __name__ == '__main__':
    app.run()===== ./app/static/__init__.py =====
===== ./app/templates/account_form.html =====
<!-- app/templates/account_form.html -->

{% extends "base.html" %}

{% block title %}Create Account{% endblock %}

{% block content %}
<h2>Create New Account</h2>
<form method="post">
    {{ form.hidden_tag() }}
    
    <!-- Display Form Errors -->
    {% if form.errors %}
        <ul class="errors">
            {% for field, errors in form.errors.items() %}
                {% for error in errors %}
                    <li>{{ error }}</li>
                {% endfor %}
            {% endfor %}
        </ul>
    {% endif %}
    
    <p>
        {{ form.name.label }}<br>
        {{ form.name(size=32) }}
    </p>
    <p>
        {{ form.type.label }}<br>
        {{ form.type() }}
    </p>
    <p>{{ form.submit() }}</p>
</form>
{% endblock %}
===== ./app/templates/account_list.html =====
<!-- app/templates/account_list.html -->

{% extends "base.html" %}

{% block title %}Account List{% endblock %}

{% block content %}
<h1>Accounts</h1>
<ul>
    {% for account in accounts %}
        <li>{{ account.name }} - {{ account.type }}</li>
    {% endfor %}
</ul>
<a href="{{ url_for('accounts.new_account') }}">Create New Account</a>
{% endblock %}
===== ./app/templates/base.html =====
<!-- app/templates/base.html -->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>{% block title %}Bookkeeping App{% endblock %}</title>
    
    <!-- Add CSS Styles for Error Messages and Flash Messages -->
    <style>
        /* Style for form validation errors */
        .errors {
            color: red;
            list-style-type: none;
            padding: 0;
        }

        /* Style for flash messages */
        .flash-message {
            padding: 10px;
            margin-bottom: 20px;
            border-radius: 5px;
        }

        .flash-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .flash-message.danger {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>
    {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
            <div class="flash-messages">
                {% for category, message in messages %}
                    <div class="flash-message {{ category }}">
                        {{ message }}
                    </div>
                {% endfor %}
            </div>
        {% endif %}
    {% endwith %}
    {% block content %}{% endblock %}
</body>
</html>
===== ./app/templates/index.html =====
<!-- app/templates/index.html -->

{% extends "base.html" %}

{% block title %}Home - Bookkeeping App{% endblock %}

{% block content %}
<h1>Welcome to the Bookkeeping Application</h1>
<nav>
    <a href="{{ url_for('auth.login') }}">Login</a> |
    <a href="{{ url_for('accounts.list_accounts') }}">Accounts</a> |
    <a href="{{ url_for('transactions.list_transactions') }}">Transactions</a>
</nav>
{% endblock %}
===== ./app/templates/login.html =====
<!-- app/templates/login.html -->

{% extends "base.html" %}

{% block title %}Login{% endblock %}

{% block content %}
<h2>Login</h2>
<form method="post">
    {{ form.hidden_tag() }}
    <p>
        {{ form.username.label }}<br>
        {{ form.username(size=32) }}
    </p>
    <p>
        {{ form.password.label }}<br>
        {{ form.password(size=32) }}
    </p>
    <p>{{ form.submit() }}</p>
</form>
{% endblock %}
===== ./app/templates/transaction_form.html =====
<!-- app/templates/transaction_form.html -->

{% extends "base.html" %}

{% block title %}Create Transaction{% endblock %}

{% block content %}
<h2>Create New Transaction</h2>
<form method="post">
    {{ form.hidden_tag() }}
    <p>
        {{ form.date.label }}<br>
        {{ form.date() }}
    </p>
    <p>
        {{ form.amount.label }}<br>
        {{ form.amount() }}
    </p>
    <p>
        {{ form.description.label }}<br>
        {{ form.description(size=64) }}
    </p>
    <p>
        {{ form.debit_account.label }}<br>
        {{ form.debit_account() }}
    </p>
    <p>
        {{ form.credit_account.label }}<br>
        {{ form.credit_account() }}
    </p>
    <p>{{ form.submit() }}</p>
</form>
{% endblock %}
===== ./app/templates/transaction_list.html =====
<!-- app/templates/transaction_list.html -->

{% extends "base.html" %}

{% block title %}Transaction List{% endblock %}

{% block content %}
<h2>Transactions</h2>
<ul>
    {% for transaction in transactions %}
        <li>{{ transaction.description }} - {{ transaction.amount }} on {{ transaction.date.strftime('%Y-%m-%d %H:%M:%S') }}</li>
    {% endfor %}
</ul>
<a href="{{ url_for('transactions.new_transaction') }}">Create New Transaction</a>
{% endblock %}
===== ./app/templates/__init__.py =====
===== ./app/views/accounts.py =====
# app/views/accounts.py

from flask import Blueprint, render_template, redirect, url_for, flash, request
from modules.forms.account_form import AccountForm
from modules.models.account import Account
from modules.database.db import db
from flask_login import login_required

bp = Blueprint('accounts', __name__, url_prefix='/accounts')

@bp.route('/new', methods=['GET', 'POST'])
@login_required
def new_account():
    form = AccountForm()
    if form.validate_on_submit():
        account = Account(
            name=form.name.data,
            type=form.type.data
        )
        db.session.add(account)
        db.session.commit()
        flash('Account created successfully.', 'success')
        return redirect(url_for('accounts.list_accounts'))
    return render_template('account_form.html', form=form)


@bp.route('/', methods=['GET'])
@login_required
def list_accounts():
    accounts = Account.query.all()
    return render_template('account_list.html', accounts=accounts)
===== ./app/views/auth.py =====
# app/views/auth.py

from flask import Blueprint, render_template, redirect, url_for, flash, request
from modules.forms.login_form import LoginForm
from modules.models.user import User
from modules.database.db import db
from werkzeug.security import check_password_hash
from flask_login import login_user, logout_user, login_required

bp = Blueprint('auth', __name__, url_prefix='/auth')

@bp.route('/login', methods=['GET', 'POST'])
def login():
    form = LoginForm()
    if form.validate_on_submit():
        user = User.query.filter_by(username=form.username.data).first()
        if user and check_password_hash(user.password_hash, form.password.data):
            login_user(user)
            flash('Logged in successfully.', 'success')
            return redirect(url_for('main.index'))
        else:
            flash('Invalid username or password.', 'danger')
            return render_template('login.html', form=form), 400  # Return 400 on failure
    return render_template('login.html', form=form)

@bp.route('/logout')
@login_required
def logout():
    logout_user()
    flash('You have been logged out.', 'success')
    return redirect(url_for('main.index'))
===== ./app/views/main.py =====
# app/views/main.py

from flask import Blueprint, render_template

bp = Blueprint('main', __name__, url_prefix='/')

@bp.route('/')
def index():
    return render_template('index.html')  # Ensure this template exists
===== ./app/views/transactions.py =====
# app/views/transactions.py

from flask import Blueprint, render_template, redirect, url_for, flash, request
from modules.forms.transaction_form import TransactionForm
from modules.models.transaction import Transaction
from modules.models.account import Account
from modules.database.db import db
from sqlalchemy.exc import IntegrityError
from flask_login import login_required

bp = Blueprint('transactions', __name__, url_prefix='/transactions')

@bp.route('/new', methods=['GET', 'POST'])
@login_required
def new_transaction():
    form = TransactionForm()
    # Populate account choices
    form.debit_account.choices = [(account.id, account.name) for account in Account.query.all()]
    form.credit_account.choices = [(account.id, account.name) for account in Account.query.all()]
    
    if form.validate_on_submit():
        transaction = Transaction(
            date=form.date.data,
            amount=form.amount.data,
            description=form.description.data,
            debit_account_id=form.debit_account.data,
            credit_account_id=form.credit_account.data
        )
        db.session.add(transaction)
        try:
            db.session.commit()
            flash('Transaction created successfully.', 'success')
            return redirect(url_for('transactions.list_transactions'))
        except IntegrityError:
            db.session.rollback()
            flash('Error creating transaction.', 'danger')
            return render_template('transaction_form.html', form=form), 400
    return render_template('transaction_form.html', form=form)

@bp.route('/', methods=['GET'])
@login_required
def list_transactions():
    transactions = Transaction.query.all()
    return render_template('transaction_list.html', transactions=transactions)
===== ./app/views/__init__.py =====
# app/views/__init__.py

from app.views.accounts import bp as accounts_bp
from app.views.transactions import bp as transactions_bp
from app.views.auth import bp as auth_bp

__all__ = ['accounts_bp', 'transactions_bp', 'auth_bp']
===== ./app/__init__.py =====
# app/__init__.py

from flask import Flask
from modules.database.db import db
from flask_migrate import Migrate
from flask_login import LoginManager
from app.views.main import bp as main_bp
from app.views.auth import bp as auth_bp
from app.views.accounts import bp as accounts_bp
from app.views.transactions import bp as transactions_bp

def create_app(config_object='config.DevelopmentConfig'):
    app = Flask(__name__)
    app.config.from_object(config_object)

    # Initialize extensions
    db.init_app(app)
    migrate = Migrate(app, db)

    # Initialize Flask-Login
    login_manager = LoginManager()
    login_manager.login_view = 'auth.login'
    login_manager.init_app(app)

    @login_manager.user_loader
    def load_user(user_id):
        from modules.models.user import User
        return User.query.get(int(user_id))

    # Register Blueprints
    app.register_blueprint(main_bp)
    app.register_blueprint(auth_bp)
    app.register_blueprint(accounts_bp)
    app.register_blueprint(transactions_bp)

    return app
===== ./config.py =====
# config.py
import os

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY', 'your_secret_key')
    
    # Generate absolute path for the database
    basedir = os.path.abspath(os.path.dirname(__file__))
    SQLALCHEMY_DATABASE_URI = 'sqlite:///' + os.path.join(basedir, 'data', 'app.db')
    
    SQLALCHEMY_TRACK_MODIFICATIONS = False

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'  # In-memory DB for testing
    WTF_CSRF_ENABLED = False  # Disable CSRF for testing
===== ./migrations/env.py =====
import logging
from logging.config import fileConfig

from flask import current_app

from alembic import context

# this is the Alembic Config object, which provides
# access to the values within the .ini file in use.
config = context.config

# Interpret the config file for Python logging.
# This line sets up loggers basically.
fileConfig(config.config_file_name)
logger = logging.getLogger('alembic.env')


def get_engine():
    try:
        # this works with Flask-SQLAlchemy<3 and Alchemical
        return current_app.extensions['migrate'].db.get_engine()
    except (TypeError, AttributeError):
        # this works with Flask-SQLAlchemy>=3
        return current_app.extensions['migrate'].db.engine


def get_engine_url():
    try:
        return get_engine().url.render_as_string(hide_password=False).replace(
            '%', '%%')
    except AttributeError:
        return str(get_engine().url).replace('%', '%%')


# add your model's MetaData object here
# for 'autogenerate' support
# from myapp import mymodel
# target_metadata = mymodel.Base.metadata
config.set_main_option('sqlalchemy.url', get_engine_url())
target_db = current_app.extensions['migrate'].db

# other values from the config, defined by the needs of env.py,
# can be acquired:
# my_important_option = config.get_main_option("my_important_option")
# ... etc.


def get_metadata():
    if hasattr(target_db, 'metadatas'):
        return target_db.metadatas[None]
    return target_db.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    url = config.get_main_option("sqlalchemy.url")
    context.configure(
        url=url, target_metadata=get_metadata(), literal_binds=True
    )

    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """

    # this callback is used to prevent an auto-migration from being generated
    # when there are no changes to the schema
    # reference: http://alembic.zzzcomputing.com/en/latest/cookbook.html
    def process_revision_directives(context, revision, directives):
        if getattr(config.cmd_opts, 'autogenerate', False):
            script = directives[0]
            if script.upgrade_ops.is_empty():
                directives[:] = []
                logger.info('No changes in schema detected.')

    conf_args = current_app.extensions['migrate'].configure_args
    if conf_args.get("process_revision_directives") is None:
        conf_args["process_revision_directives"] = process_revision_directives

    connectable = get_engine()

    with connectable.connect() as connection:
        context.configure(
            connection=connection,
            target_metadata=get_metadata(),
            **conf_args
        )

        with context.begin_transaction():
            context.run_migrations()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()
===== ./migrations/versions/e70c7b1df6a5_initial_migration.py =====
"""Initial migration

Revision ID: e70c7b1df6a5
Revises: 
Create Date: 2024-11-05 18:37:16.754153

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = 'e70c7b1df6a5'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('accounts',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('name', sa.String(length=150), nullable=False),
    sa.Column('type', sa.String(length=50), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('name')
    )
    op.create_table('users',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('username', sa.String(length=150), nullable=False),
    sa.Column('password_hash', sa.String(length=255), nullable=False),
    sa.Column('role', sa.String(length=50), nullable=False),
    sa.PrimaryKeyConstraint('id'),
    sa.UniqueConstraint('username')
    )
    op.create_table('transactions',
    sa.Column('id', sa.Integer(), nullable=False),
    sa.Column('date', sa.DateTime(), nullable=False),
    sa.Column('amount', sa.Float(), nullable=False),
    sa.Column('description', sa.String(length=255), nullable=False),
    sa.Column('debit_account_id', sa.Integer(), nullable=False),
    sa.Column('credit_account_id', sa.Integer(), nullable=False),
    sa.ForeignKeyConstraint(['credit_account_id'], ['accounts.id'], ),
    sa.ForeignKeyConstraint(['debit_account_id'], ['accounts.id'], ),
    sa.PrimaryKeyConstraint('id')
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('transactions')
    op.drop_table('users')
    op.drop_table('accounts')
    # ### end Alembic commands ###
===== ./modules/database/db.py =====
# modules/database/db.py
from flask_sqlalchemy import SQLAlchemy

db = SQLAlchemy()===== ./modules/database/__init__.py =====
===== ./modules/forms/account_form.py =====
# modules/forms/account_form.py
from flask_wtf import FlaskForm
from wtforms import StringField, SelectField, SubmitField
from wtforms.validators import DataRequired, ValidationError
from modules.models.account import Account

class AccountForm(FlaskForm):
    name = StringField('Account Name', validators=[DataRequired()])
    type = SelectField('Account Type', choices=[
        ('Asset', 'Asset'),
        ('Liability', 'Liability'),
        ('Equity', 'Equity'),
        ('Revenue', 'Revenue'),
        ('Expense', 'Expense')
    ], validators=[DataRequired()])
    submit = SubmitField('Create Account')

    def validate_name(self, field):
        if Account.query.filter_by(name=field.data).first():
            raise ValidationError('Account name already exists.')===== ./modules/forms/login_form.py =====
# modules/forms/login_form.py

from flask_wtf import FlaskForm
from wtforms import StringField, PasswordField, SubmitField
from wtforms.validators import DataRequired

class LoginForm(FlaskForm):
    username = StringField('Username', validators=[DataRequired()])
    password = PasswordField('Password', validators=[DataRequired()])
    submit = SubmitField('Login')
===== ./modules/forms/transaction_form.py =====
# modules/forms/transaction_form.py

from flask_wtf import FlaskForm
from wtforms import StringField, FloatField, SelectField, DateTimeField, SubmitField
from wtforms.validators import DataRequired

class TransactionForm(FlaskForm):
    date = DateTimeField('Date', validators=[DataRequired()])
    amount = FloatField('Amount', validators=[DataRequired()])
    description = StringField('Description', validators=[DataRequired()])
    debit_account = SelectField('Debit Account', coerce=int, validators=[DataRequired()])
    credit_account = SelectField('Credit Account', coerce=int, validators=[DataRequired()])
    submit = SubmitField('Create Transaction')
===== ./modules/forms/__init__.py =====
===== ./modules/ml/models/__init__.py =====
===== ./modules/ml/training/__init__.py =====
===== ./modules/ml/utils/__init__.py =====
===== ./modules/ml/__init__.py =====
===== ./modules/models/account.py =====
# modules/models/account.py

from modules.database.db import db

class Account(db.Model):
    __tablename__ = 'accounts'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(150), unique=True, nullable=False)
    type = db.Column(db.String(50), nullable=False)

    def __repr__(self):
        return f"<Account {self.name}>"
===== ./modules/models/transaction.py =====
# modules/models/transaction.py

from modules.database.db import db
from modules.models.account import Account

class Transaction(db.Model):
    __tablename__ = 'transactions'
    id = db.Column(db.Integer, primary_key=True)
    date = db.Column(db.DateTime, nullable=False)
    amount = db.Column(db.Float, nullable=False)
    description = db.Column(db.String(255), nullable=False)
    debit_account_id = db.Column(db.Integer, db.ForeignKey('accounts.id'), nullable=False)
    credit_account_id = db.Column(db.Integer, db.ForeignKey('accounts.id'), nullable=False)

    debit_account = db.relationship('Account', foreign_keys=[debit_account_id])
    credit_account = db.relationship('Account', foreign_keys=[credit_account_id])

    def __repr__(self):
        return f"<Transaction {self.id} - {self.description}>"
===== ./modules/models/user.py =====
# modules/models/user.py

from modules.database.db import db
from flask_login import UserMixin

class User(UserMixin, db.Model):
    __tablename__ = 'users'
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(150), unique=True, nullable=False)
    password_hash = db.Column(db.String(255), nullable=False)
    role = db.Column(db.String(50), nullable=False)

    def __repr__(self):
        return f"<User {self.username}>"
===== ./modules/models/__init__.py =====
===== ./modules/services/__init__.py =====
===== ./modules/__init__.py =====
===== ./tests/conftest.py =====
# tests/conftest.py

import pytest
from app import create_app
from modules.database.db import db as _db
from modules.models.user import User
from werkzeug.security import generate_password_hash

@pytest.fixture(scope='session')
def app():
    app = create_app('config.TestingConfig')  # Use TestingConfig
    app.config['TESTING'] = True
    # The following configurations are already set in TestingConfig
    # app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///:memory:'
    # app.config['WTF_CSRF_ENABLED'] = False

    with app.app_context():
        _db.create_all()
        # Create a test user
        test_user = User(
            username='testuser',
            password_hash=generate_password_hash('testpassword'),
            role='Admin'
        )
        _db.session.add(test_user)
        _db.session.commit()
        yield app
        _db.drop_all()

@pytest.fixture(scope='session')
def db(app):
    return _db

@pytest.fixture(scope='function')
def client(app, db):
    with app.test_client() as client:
        # Log in the test user
        response = client.post('/auth/login', data={
            'username': 'testuser',
            'password': 'testpassword'
        }, follow_redirects=True)
        yield client
        # Log out after test
        response = client.get('/auth/logout', follow_redirects=True)
        # Rollback the session to clean up after the test
        db.session.rollback()
===== ./tests/test_models.py =====
# tests/test_models.py

from datetime import datetime, timezone

def test_transaction_model(db):
    from modules.models.account import Account
    from modules.models.transaction import Transaction

    # Add unique accounts
    debit_account = Account(name='Cash_Test', type='Asset')
    credit_account = Account(name='Revenue_Test', type='Revenue')

    db.session.add_all([debit_account, credit_account])
    db.session.commit()

    # Create a transaction with timezone-aware date
    transaction = Transaction(
        date=datetime.now(timezone.utc),  # Updated datetime
        debit_account_id=debit_account.id,
        credit_account_id=credit_account.id,
        amount=1000.00,
        description='Test Transaction'
    )

    db.session.add(transaction)
    db.session.commit()

    # Assertions
    assert transaction.id is not None
    assert transaction.debit_account.name == 'Cash_Test'
    assert transaction.credit_account.name == 'Revenue_Test'
===== ./tests/test_views.py =====
# tests/test_views.py

from datetime import datetime, timezone
from modules.models.account import Account
from modules.models.transaction import Transaction

def test_new_account(client, db):
    # Create a unique account name using timestamp
    unique_account_name = f'Bank_Test_{datetime.now(timezone.utc).timestamp()}'

    # Create the account successfully
    response = client.post('/accounts/new', data={
        'name': unique_account_name,
        'type': 'Asset'
    }, follow_redirects=True)

    assert response.status_code == 200
    assert b'Account created successfully' in response.data  # Adjust based on your flash message

    # Attempt to create the same account again to test uniqueness
    response_duplicate = client.post('/accounts/new', data={
        'name': unique_account_name,
        'type': 'Asset'
    }, follow_redirects=True)

    assert response_duplicate.status_code == 200  # Expecting OK status with form re-rendered
    assert b'Account name already exists' in response_duplicate.data  # Verify error message
===== ./tests/__init__.py =====
